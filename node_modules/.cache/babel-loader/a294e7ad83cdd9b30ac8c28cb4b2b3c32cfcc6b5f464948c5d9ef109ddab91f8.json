{"ast":null,"code":"import { space } from '@shopify/polaris-tokens';\nimport { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n  setContainer(el) {\n    this.container = el;\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(space['space-5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || stickyNode.firstElementChild?.getBoundingClientRect().height || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n      count++;\n    }\n    return offset;\n  }\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n}\nfunction isDocument(node) {\n  return node === document;\n}\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\nexport { StickyManager };","map":{"version":3,"names":["space","debounce","scrollable","dataPolarisTopBar","stackedContent","getRectForNode","SIXTY_FPS","StickyManager","constructor","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","registerStickyItem","stickyItem","push","unregisterStickyItem","nodeToRemove","nodeIndex","findIndex","stickyNode","splice","el","isDocument","setTopBarOffset","addEventListener","window","removeScrollListener","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","sticky","left","width","evaluateStickyItem","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","stickyItemHeight","height","firstElementChild","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","node","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"sources":["/Users/nick/Documents/app info front ui/node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/sticky-manager.js"],"sourcesContent":["import { space } from '@shopify/polaris-tokens';\nimport { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\n\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n  setContainer(el) {\n    this.container = el;\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(space['space-5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || stickyNode.firstElementChild?.getBoundingClientRect().height || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n      count++;\n    }\n    return offset;\n  }\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n}\nfunction isDocument(node) {\n  return node === document;\n}\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}